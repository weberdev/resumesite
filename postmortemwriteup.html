<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ian Weber</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<h1>Another game jam done, thus another debrief for LinkedIn content. <i>This was written as linkedin content, but I ran out of characters about a quarter of the way in.</i></h1>

Mere hours after presenting Ephemeral (a project I worked on for the UVGD summer jam), I was invited to another game jam. This time a cross-disciplinary one: my team was not formed by sending Discord messages to CST friends from Camosun, instead, a friend of mine who teaches high school computing reached out about something unrelated, and it turns out he was starting his jam as I finished mine. After a moment's deliberation, I signed on. Apparently the assumed team that I'd want to be paid for a programming project and held off on the invitation. That is correct, yes, but that's a touch optimistic right now.

Working with non-engineering adjacent people is very different. You can know how to program, teach it to high school students, and have never used Git. I can't handle teenagers, and nor do I do Excel. Different people have different talents. As it turns out, git is exciting if you've never used it before, and people who understand the basics take to it well.

It was decided that Game Maker Studio would be used. It's a lot better as a teaching tool than Godot or Unity, according to the teachers involved in the project, and so we skipped out on the industry-adjacent engines I've used before. A new tool is always exciting to use, which is why I regularly go to the hardware store to buy hammers- that and juggling.

Now, scheduling and goals differed here. I'm pretty much on an extended summer vacation while I look for a career position, and my team lead is a new dad. I probably don't need to tell you that family is more important than game development. That being said, family is more important than game development. My goal was to ship something under crunch, and everyone else's was to learn Game Maker to present it to students. These are both valid goals, but they're not perfectly aligned.  Initially, I found found myself operating as lead programmer and requirements engineer, grinding out the basis of the project, and ensuring that I understood what was being asked for in the design document. Writing your first design doc is uphill work, and I can't judge given what a mess my first design doc was. That said, I took a red pen to our document to clarify what was needed. Would you believe that writing assignments and lesson plans differs from writing technicial specifications?

Logistics aren't that interesting, so I'll talk about the dev cycle instead: we had a pitch document and some basic mechanical ideas. I started sketching out an implementation that matched the design doc, but not the initial vision. GMS is pretty easy to work with bar a few early peculiarities: it feels close to a dedicated image editing program than Unity or Godot, and is definitely more user friendly- there's a bit of an engine elitism involved, something that I've had to consider, but setting up basic gameplay functions is pretty easy. The problem that I ran into, on that note, is that I wrote my initial draft like a CRUD app: after being informed that the project should involve discrete tiles instead of smooth movement, I wrote everything in the first draft based on checking for values at coordinates, almost as though I was iterating through a 2d array. As I became more familiar with the toolset, I realized that I was looking at it in completely the wrong frame of mind: I didn't have to create a global list of switch positions and figure out how to ⍕ out object IDs and ⍎ them back into strings when I wanted to work with them. 


What I learned from this trip into APL thinking is that I can use tools most effectively by working with them, not against them. When I remembered that I was writing a game rather than an interpreter, and I began to look at the built in options more clearly, development became a breeze. Mostly. While certain software development methodologies are ill-suited to game development, formal specfications are not one of them. I'll illustrate this with a simple example that caused a lot of problems. The protagonist of the game was intended to squeeze through grates and emerge from the other side. This was to be used in puzzles to allow access to different areas. I wrote some code to implement that, checking on keypress if the faced tile was a grate, and if the tile beyond the grate was open. Little did I know that the intent of the designer was to generalize this, to allow the protagonist to move through a tunnel or series of grates when necessary. That's fine, I updated my code to check to see if the area was either open or a tunnel, and try again. Easily fixed. Finally, the level came in, and we had a problem. The painstakingly handcrafted map that I was given included an area with a bridge that was to be crossed with a tunnel underneath. In order to cross the bridge, the collider needed to be removed from the tunnel and grates. To do that and not break other things, we needed to reimplement how movement worked. I reimplemented how movement worked.

Art arrived, giving the slime an animation for oozing into the tunnel and oozing out. A new implementation was necessary to play the full animation, move the slime, do the opposite animation for leaving the tunnel. Coded didn't work. Time ran out. What did we learn?

It's important to know how the feature you're implementing is actually going to be used. Sliding through grates ate a non-trivial amount of development time, and it still needs to be redone. I'm sure there's a grate solution I can implement quickly, but I'm writing my NMF doc right now. 

Spend time wisely. I had code for pushing around items wit⍺h a gust of wind almost working for an hour, and could not disengage from that until it was fixed and ran perfectly. In time, it did. We did not use it in the released proof of concept level. 

Things generalize. I wrote code to launch a fireball. I set it to travel in the slime's facing direction, to garbage collect itself after a specific time, and to collide with things. I also learned how GMS handled facing and rotation. Did we use that object? No. Was that time wasted? Absolutely not: everything I did with the fireball generalized to the game's collision system (could've read the manual), facing system (could've read the manual), and object interaction system (could have read the manual). 

Learn your tools before you use them. I feel like I know GMS a lot better than I did two weeks ago. Subsuming myself in a project for 60 hours will do that. If I was to start over with a project in the same of similar scale and a similar level of design detail, I'd be able to lead the development of a much more complete product.


All in all, I really enjoyed working on the project, and I learned a fair bit. Not only about the tools I was using, but about software design in general.
</body>
</HTML>